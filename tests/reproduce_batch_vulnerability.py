
import sys
import unittest
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import Qt, QPoint

# Hardcode project root
import os
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from gui.widgets.splitter_strip import SplitterStripWidget, PageThumbnailWidget, SplitDividerWidget, DragPlaceholderWidget

class TestBatchBoundaryEnforcement(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.app = QApplication.instance() or QApplication(sys.argv)

    def test_batch_locking(self):
        print("\nVerifying Batch Boundary Enforcement...")
        strip = SplitterStripWidget()
        strip.import_mode = True # Critical!
        
        # Mimic 3 files, each 1 page
        file_paths = ["file1.pdf", "file2.pdf", "file3.pdf"]
        # We simulate the result of load_from_paths
        all_pages = [
            {"file_uuid": "FILE_0", "file_path": "f1", "page": 1, "rotation": 0, "is_boundary": False},
            {"file_uuid": "FILE_1", "file_path": "f2", "page": 1, "rotation": 0, "is_boundary": True},
            {"file_uuid": "FILE_2", "file_path": "f3", "page": 1, "rotation": 0, "is_boundary": True}
        ]
        strip._populate_strip(all_pages)
        strip.show() # Force layout
        
        # Sequence should be: [T0, D1(boundary/active), T1, D2(boundary/active), T2]
        # Layout count: 5
        self.assertEqual(strip.content_layout.count(), 5)
        
        t0 = strip.content_layout.itemAt(0).widget()
        d1 = strip.content_layout.itemAt(1).widget()
        t1 = strip.content_layout.itemAt(2).widget()
        d2 = strip.content_layout.itemAt(3).widget()
        t2 = strip.content_layout.itemAt(4).widget()
        
        self.assertTrue(isinstance(t1, PageThumbnailWidget))
        self.assertTrue(isinstance(d1, SplitDividerWidget))
        self.assertTrue(d1.is_active, "Boundary D1 should be active")
        self.assertTrue(d1.is_boundary, "Boundary D1 should be marked as boundary")
        self.assertTrue(d2.is_active, "Boundary D2 should be active")
        
        # 1. Simulate Drag T1 (The middle one-page document)
        strip.selected_widgets = [t1]
        t1.hide()
        
        # Create Gap
        strip.drag_placeholder_width = t1.width()
        strip.drag_placeholder = DragPlaceholderWidget(strip.drag_placeholder_width, strip)
        strip.content_layout.insertWidget(2, strip.drag_placeholder)
        
        # Current indices: T0(0), D1(1), Gap(2), T1(3,hidden), D2(4), T2(5)
        self.assertEqual(strip.content_layout.indexOf(strip.drag_placeholder), 2)
        
        # Force a move DEEP into T0 (index 0)
        t0_geo = t0.geometry()
        # Mouse is at the very left of the widget
        p_left = QPoint(t0_geo.left() + 5, t0_geo.center().y())
        
        idx, neighbor = strip._calculate_target_index_stable(p_left)
        print(f"Move LEFT into T0: target_idx={idx}, neighbor={neighbor}")
        self.assertIsNone(idx, "Wall D1 (active) failed to block move to T0!")
        
        # Force a move DEEP into T2 (index 5)
        t2_geo = t2.geometry()
        p_right = QPoint(t2_geo.right() - 5, t2_geo.center().y())
        idx, neighbor = strip._calculate_target_index_stable(p_right)
        print(f"Move RIGHT into T2: target_idx={idx}, neighbor={neighbor}")
        self.assertIsNone(idx, "Wall D2 (active) failed to block move to T2!")

        print("Verification: One-page segments are IMMOBILE. Test PASSED.")

if __name__ == "__main__":
    unittest.main()
